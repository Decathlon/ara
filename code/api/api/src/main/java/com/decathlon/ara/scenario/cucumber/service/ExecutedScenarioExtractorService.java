/******************************************************************************
 * Copyright (C) 2019 by the ARA Contributors                                 *
 *                                                                            *
 * Licensed under the Apache License, Version 2.0 (the "License");            *
 * you may not use this file except in compliance with the License.           *
 * You may obtain a copy of the License at                                    *
 *                                                                            *
 * 	 http://www.apache.org/licenses/LICENSE-2.0                               *
 *                                                                            *
 * Unless required by applicable law or agreed to in writing, software        *
 * distributed under the License is distributed on an "AS IS" BASIS,          *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
 * See the License for the specific language governing permissions and        *
 * limitations under the License.                                             *
 *                                                                            *
 ******************************************************************************/

package com.decathlon.ara.scenario.cucumber.service;

import static com.decathlon.ara.lib.embed.producer.StructuredEmbeddingsBuilder.HUMAN_AND_MACHINE_READABLE_TIMESTAMP_PATTERN;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import com.decathlon.ara.domain.ExecutedScenario;
import com.decathlon.ara.lib.embed.consumer.StructuredEmbeddingsHolder;
import com.decathlon.ara.scenario.cucumber.asset.AssetService;
import com.decathlon.ara.scenario.cucumber.bean.Element;
import com.decathlon.ara.scenario.cucumber.bean.Feature;
import com.decathlon.ara.scenario.cucumber.bean.Tag;
import com.decathlon.ara.scenario.cucumber.util.CucumberReportUtil;
import com.decathlon.ara.scenario.cucumber.util.ErrorExtractorUtil;
import com.decathlon.ara.scenario.cucumber.util.ScenarioExtractorUtil;
import com.google.common.collect.Sets;

/**
 * A service on top ScenarioExtractorUtil and ErrorExtractorUtil, that allow to upload screenshots to a server if they are embedded in regular Cucumber embeds, instead of StructuredEmbeddings.
 */
@Service
public class ExecutedScenarioExtractorService {

    private static final Logger LOG = LoggerFactory.getLogger(ExecutedScenarioExtractorService.class);

    private final AssetService assetService;

    public ExecutedScenarioExtractorService(AssetService assetService) {
        this.assetService = assetService;
    }

    /**
     * @param features        a parsed Cucumber's report.json file/stream
     * @param stepDefinitions a parsed stepDefinitions.json file/stream generated by functional-test-base-core's CliRunner containing a list of
     *                        regular expressions for all known Cucumber' steps
     * @param runJobUrl       the continuous integration job URL of the run of these features
     * @return a list of executed-scenarios, with errors for failed scenarios; screenshots have been uploaded; all errors have no Run associated with
     */
    public List<ExecutedScenario> extractExecutedScenarios(List<Feature> features, List<String> stepDefinitions, String runJobUrl) {
        final List<ExecutedScenario> executedScenarios = new ArrayList<>();
        ExecutedScenario lastBackground = null;
        for (Feature feature : features) {
            for (Element element : feature.getElements()) {
                if (element.isBackground()) {
                    lastBackground = extractBackground(stepDefinitions, element);
                } else if (element.isScenario()) {
                    executedScenarios.add(extractExecutedScenario(stepDefinitions, feature, element, runJobUrl, lastBackground));
                    lastBackground = null;
                }
            }
            lastBackground = null;
        }
        return executedScenarios;
    }

    private ExecutedScenario extractBackground(List<String> stepDefinitions, Element element) {
        ExecutedScenario background = new ExecutedScenario();
        background.setContent(CucumberReportUtil.extractScenarioContent(element, null));
        background.addErrors(ErrorExtractorUtil.extractErrors(stepDefinitions, element.getSteps(), null));
        return background;
    }

    private ExecutedScenario extractExecutedScenario(List<String> stepDefinitions, Feature feature, Element scenario, String runJobUrl, ExecutedScenario lastBackground) {
        Set<String> featureTags = Tag.names(feature.getTags());
        Set<String> scenarioTags = Tag.names(scenario.getTags());
        Set<String> allTags = Sets.union(featureTags, scenarioTags);

        // If the project is using StructuredEmbeddings, they have priority
        Optional<StructuredEmbeddingsHolder> structuredEmbeddings = scenario.extractStructuredEmbeddings();

        ExecutedScenario executedScenario = new ExecutedScenario();
        executedScenario.setFeatureFile(feature.getUri());
        executedScenario.setFeatureName(feature.getName());
        executedScenario.setFeatureTags(String.join(" ", featureTags));
        executedScenario.setTags(String.join(" ", scenarioTags));
        executedScenario.setSeverity(Tag.extractSeverity(allTags, scenario.getName()));
        executedScenario.setName(scenario.getName());
        executedScenario.setCucumberId(ScenarioExtractorUtil.removeFunctionalitiesFromScenarioCucumberId(scenario.getId()));
        executedScenario.setLine(scenario.getLine().intValue());
        executedScenario.setContent(CucumberReportUtil.extractScenarioContent(scenario, lastBackground == null ? null : lastBackground.getContent()));
        executedScenario.setStartDateTime(extractStartDateTime(structuredEmbeddings));
        executedScenario.setScreenshotUrl(extractScreenshotUrl(structuredEmbeddings, scenario));
        executedScenario.setVideoUrl(extractVideoUrl(structuredEmbeddings, scenario));
        executedScenario.setLogsUrl(extractStringData(structuredEmbeddings, "logsUrl"));
        executedScenario.setHttpRequestsUrl(extractStringData(structuredEmbeddings, "httpRequestsUrl"));
        executedScenario.setJavaScriptErrorsUrl(extractStringData(structuredEmbeddings, "javaScriptErrorsUrl"));
        executedScenario.setDiffReportUrl(extractStringData(structuredEmbeddings, "diffReportUrl"));
        executedScenario.setCucumberReportUrl(runJobUrl + "cucumber-html-reports/report-feature_" + feature.getReportFileName());
        executedScenario.setApiServer(extractStringData(structuredEmbeddings, "apiServer"));
        executedScenario.setSeleniumNode(extractStringData(structuredEmbeddings, "seleniumNode"));

        // Get all errors from steps and hooks, if any
        if (lastBackground != null) {
            executedScenario.addErrors(lastBackground.getErrors());
        }
        executedScenario.addErrors(ErrorExtractorUtil.extractErrors(stepDefinitions, scenario.getBefore(), "@Before"));
        executedScenario.addErrors(ErrorExtractorUtil.extractErrors(stepDefinitions, scenario.getSteps(), null));
        executedScenario.addErrors(ErrorExtractorUtil.extractErrors(stepDefinitions, scenario.getAfter(), "@After"));

        return executedScenario;
    }

    private String extractScreenshotUrl(Optional<StructuredEmbeddingsHolder> structuredEmbeddings, Element scenario) {
        return structuredEmbeddings
                .flatMap(e -> e.extractStringData("screenshotUrl"))
                .orElseGet(() -> scenario.extractScreenshot()
                        .map(bytes -> assetService.saveScreenshot(bytes, scenario.getName()))
                        .orElse(null));
    }

    private String extractVideoUrl(Optional<StructuredEmbeddingsHolder> structuredEmbeddings, Element scenario) {
        return structuredEmbeddings
                .flatMap(e -> e.extractStringData("videoUrl"))
                .orElseGet(() -> scenario.extractVideoUrl()
                        .orElse(null));
    }

    private String extractStringData(Optional<StructuredEmbeddingsHolder> structuredEmbeddings, String kind) {
        return structuredEmbeddings
                .flatMap(e -> e.extractStringData(kind))
                .orElse(null);
    }

    private Date extractStartDateTime(Optional<StructuredEmbeddingsHolder> structuredEmbeddings) {
        return structuredEmbeddings
                .flatMap(e -> e.extractStringData("startDateTime"))
                .map(s -> {
                    try {
                        return new SimpleDateFormat(HUMAN_AND_MACHINE_READABLE_TIMESTAMP_PATTERN).parse(s);
                    } catch (ParseException e) {
                        LOG.error("Cannot parse start date&time: {}", s, e);
                        return null;
                    }
                })
                .orElse(null);
    }

}
