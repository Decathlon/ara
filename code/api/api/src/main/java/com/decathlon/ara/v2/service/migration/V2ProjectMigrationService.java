package com.decathlon.ara.v2.service.migration;

import com.decathlon.ara.domain.Country;
import com.decathlon.ara.domain.CycleDefinition;
import com.decathlon.ara.domain.ProblemPattern;
import com.decathlon.ara.domain.Type;
import com.decathlon.ara.repository.*;
import com.decathlon.ara.v2.domain.*;
import com.decathlon.ara.v2.domain.enumeration.ProblemStatus;
import com.decathlon.ara.v2.domain.id.CodeWithProjectId;
import com.decathlon.ara.v2.exception.BusinessException;
import com.decathlon.ara.v2.exception.project.ProjectAlreadyExistsException;
import com.decathlon.ara.v2.exception.project.UnknownProjectException;
import com.decathlon.ara.v2.repository.*;
import com.decathlon.ara.v2.service.migration.execution.V2DeploymentValidationMigrationService;
import com.decathlon.ara.v2.service.migration.feature.V2FeatureMigrationService;
import com.decathlon.ara.v2.service.migration.scenario.V2ScenarioMigrationService;
import com.mysema.commons.lang.Pair;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import javax.transaction.Transactional;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

import static java.util.stream.Collectors.groupingBy;

@Service
@RequiredArgsConstructor
@Transactional(Transactional.TxType.REQUIRED)
public class V2ProjectMigrationService {

    private static final String GENERATED_BY_MIGRATION_API = "Generated by the migration API.";
    public static final String NEW_FIELD_GENERATION = GENERATED_BY_MIGRATION_API + " This field didn't exist in the previous version.";
    public static final String FIELD_TO_RENAME = GENERATED_BY_MIGRATION_API + " Field to rename: created because no entry found";

    private final ProjectRepository legacyProjectRepository;
    private final CycleDefinitionRepository legacyCycleDefinitionRepository;
    private final SeverityRepository legacySeverityRepository;
    private final CountryRepository legacyCountryRepository;
    private final SourceRepository legacySourceRepository;
    private final TypeRepository legacyTypeRepository;
    private final ProblemRepository legacyProblemRepository;
    private final ProblemPatternRepository legacyProblemPatternRepository;
    private final TeamRepository legacyTeamRepository;
    private final RootCauseRepository legacyRootCauseRepository;
    private final ExecutionRepository legacyExecutionRepository;

    private final V2ProjectRepository migrationProjectRepository;
    private final V2BranchRepository migrationBranchRepository;
    private final V2ScenarioSeverityRepository migrationSeverityRepository;
    private final V2TagRepository migrationTagRepository;
    private final V2ScenarioTypeRepository migrationScenarioTypeRepository;
    private final V2ScenarioExecutionTypeRepository migrationScenarioExecutionTypeRepository;
    private final V2ProblemRepository migrationProblemRepository;
    private final V2ScenarioErrorTracePatternRepository migrationScenarioErrorTracePatternRepository;
    private final V2TeamRepository migrationTeamRepository;
    private final V2ProblemRootCauseRepository migrationRootCauseRepository;
    private final V2RepositoryRepository migrationRepositoryRepository;

    private final V2FeatureMigrationService featureMigrationService;
    private final V2ScenarioMigrationService scenarioMigrationService;
    private final V2DeploymentValidationMigrationService executionMigrationService;

    /**
     * Migrate a project from a code
     * @param projectCode the project code
     * @param executionsStartDate if present, the executions start date, i.e. no executions before this date
     * @return the migrated (persisted) project
     * @throws BusinessException thrown when the migration failed
     */
    public Project migrateProject(String projectCode, Optional<Date> executionsStartDate) throws BusinessException {
        var legacyProject = legacyProjectRepository.findOneByCode(projectCode);

        Boolean legacyProjectNotFound = legacyProject == null;
        if (legacyProjectNotFound) {
            throw new UnknownProjectException();
        }

        Boolean projectAlreadyMigrated = migrationProjectRepository.existsById(projectCode);
        if (projectAlreadyMigrated) {
            throw new ProjectAlreadyExistsException();
        }

        Project migratedProject = createMigrationProject(legacyProject);

        var migratedBranches = migrateBranchesAndCycles(legacyProject, migratedProject);
        var repositoryToMigrate = new Repository()
                .withUrl("url-to-update")
                .withDescription(NEW_FIELD_GENERATION)
                .withComment(NEW_FIELD_GENERATION)
                .withBranches(migratedBranches);
        migrationRepositoryRepository.save(repositoryToMigrate);
        migrateSeverities(legacyProject, migratedProject);
        var migratedTags = migrateTags(legacyProject, migratedProject);
        migrateScenarioTypesAndScenarioExecutionTypes(legacyProject, migratedProject);
        var migratedTeams = migrateTeams(legacyProject, migratedProject);
        var migratedRootCauses = migrateRootCauses(legacyProject, migratedProject);
        var migratedProblems = migrateProblems(legacyProject, migratedTeams, migratedRootCauses);
        migratePatterns(legacyProject, migratedProblems);
        var migratedFeatures = featureMigrationService.migrateFeatures(legacyProject, migratedProject);

        var projectId = legacyProject.getId();
        var legacyExecutions = executionsStartDate
                .map(date -> legacyExecutionRepository.findAllByProjectIdAndTestDateTimeAfter(projectId, date))
                .orElse(legacyExecutionRepository.findAllByProjectId(projectId));
        var migratedScenarios = scenarioMigrationService.migrateScenarios(legacyProject, migratedProject, migratedFeatures, migratedTags, legacyExecutions);
        executionMigrationService.migrateDeploymentValidation(legacyProject, migratedProject, legacyExecutions, migratedBranches, migratedScenarios);

        return migratedProject;
    }

    /**
     * Save project from the legacy project
     * @param legacyProject the legacy project
     * @return the saved project
     */
    private Project createMigrationProject(com.decathlon.ara.domain.Project legacyProject) {
        var projectToMigrate = new Project()
                .withCode(legacyProject.getCode())
                .withName(legacyProject.getName())
                .withDescription(NEW_FIELD_GENERATION);

        Project migratedProject = migrationProjectRepository.save(projectToMigrate);
        return migratedProject;
    }

    /**
     * Migrate branches and cycles
     * @param legacyProject the legacy project
     * @param migrationProject the migration project
     */
    private List<Branch> migrateBranchesAndCycles(com.decathlon.ara.domain.Project legacyProject, Project migrationProject) {
        List<CycleDefinition> allLegacyCycleDefinitions = legacyCycleDefinitionRepository.findAllByProjectIdOrderByBranchPositionAscBranchAscNameAsc(legacyProject.getId());

        Function<Map.Entry<String, List<CycleDefinition>>, Branch> legacyCycleDefinitionsByBranchCodeToBranchesFunction =
                legacyCycleDefinitionsByBranchCode -> {
            var branchCode = legacyCycleDefinitionsByBranchCode.getKey();
            var branchName = StringUtils.capitalize(branchCode);
            var legacyCycleDefinitions = legacyCycleDefinitionsByBranchCode.getValue();
            var branchPosition = legacyCycleDefinitions.stream()
                    .mapToInt(CycleDefinition::getBranchPosition)
                    .min()
                    .orElse(1);
            var migrationCycles = legacyCycleDefinitions.stream()
                    .map(cycleDefinition ->
                            Pair.of(
                                    cycleDefinition.getName().toLowerCase(),
                                    legacyCycleDefinitions.stream()
                                            .map(CycleDefinition::getName)
                                            .sorted()
                                            .collect(Collectors.toList())
                                            .indexOf(cycleDefinition.getName()) + 1
                            )
                    )
                    .map(pair ->
                            new Cycle()
                                    .withName(pair.getFirst())
                                    .withPosition(pair.getSecond())
                                    .withDescription(NEW_FIELD_GENERATION)
                    )
                    .collect(Collectors.toList());
            return new Branch()
                    .withId(new CodeWithProjectId().withProject(migrationProject).withCode(branchCode))
                    .withName(branchName)
                    .withPosition(branchPosition)
                    .withDescription(NEW_FIELD_GENERATION)
                    .withCycles(migrationCycles);
        };

        var branchesReadyForMigration = allLegacyCycleDefinitions.stream()
                .filter(legacyCycleDefinition -> StringUtils.isNotBlank(legacyCycleDefinition.getBranch()))
                .collect(groupingBy(legacyCycleDefinition -> legacyCycleDefinition.getBranch().toLowerCase()))
                .entrySet()
                .stream()
                .map(legacyCycleDefinitionsByBranchCodeToBranchesFunction)
                .collect(Collectors.toList());
        return migrationBranchRepository.saveAll(branchesReadyForMigration);
    }

    /**
     * Migrate severities
     * @param legacyProject the legacy project
     * @param migrationProject the migration project
     */
    private void migrateSeverities(com.decathlon.ara.domain.Project legacyProject, Project migrationProject) {
        var legacySeverities = legacySeverityRepository.findAllByProjectIdOrderByPosition(legacyProject.getId());
        var severitiesReadyForMigration = legacySeverities.stream()
                .map(legacySeverity -> {
                    var severityCode = legacySeverity.getCode();
                    var severityName = legacySeverity.getName();
                    var severityLevel = legacySeverity.getPosition();
                    return new ScenarioSeverity()
                            .withId(new CodeWithProjectId().withCode(severityCode).withProject(migrationProject))
                            .withName(severityName)
                            .withDescription(NEW_FIELD_GENERATION)
                            .withLevel(severityLevel);
                })
                .collect(Collectors.toList());
        migrationSeverityRepository.saveAll(severitiesReadyForMigration);
    }

    /**
     * Migrate tags
     * @param legacyProject the legacy project
     * @param migrationProject the migration project
     * @return the saved tags
     */
    private List<Tag> migrateTags(com.decathlon.ara.domain.Project legacyProject, Project migrationProject) {
        var legacyCountries = legacyCountryRepository.findAllByProjectIdOrderByCode(legacyProject.getId());
        var tagsReadyForMigration = legacyCountries.stream()
                .filter(country -> StringUtils.isNotBlank(country.getCode()))
                .map(country -> getMigrationTagFromLegacyCountry(country, migrationProject))
                .collect(Collectors.toList());
        return migrationTagRepository.saveAll(tagsReadyForMigration);
    }

    /**
     * Convert a legacy country into a migration tag
     * @param legacyCountry the legacy country
     * @param migrationProject the migration project
     * @return the converted migration tag
     */
    public static Tag getMigrationTagFromLegacyCountry(Country legacyCountry, Project migrationProject) {
        return new Tag()
                .withId(
                        new CodeWithProjectId()
                                .withProject(migrationProject)
                                .withCode(legacyCountry.getCode().toLowerCase())
                )
                .withName(legacyCountry.getName())
                .withDescription(NEW_FIELD_GENERATION);
    }

    /**
     * Migrate scenario types and scenario execution types
     * @param legacyProject the legacy project
     * @param migrationProject the migration project
     */
    private void migrateScenarioTypesAndScenarioExecutionTypes(com.decathlon.ara.domain.Project legacyProject, Project migrationProject) {
        var projectId = legacyProject.getId();
        var legacySources = legacySourceRepository.findAllByProjectIdOrderByName(projectId);
        var scenarioTypesReadyForMigration = legacySources.stream()
                .filter(legacySource -> legacySource.getTechnology() != null)
                .map(legacySource -> V2ScenarioMigrationService.getMigrationScenarioTypeFromLegacySource(legacySource, migrationProject))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());
        migrationScenarioTypeRepository.saveAll(scenarioTypesReadyForMigration);

        var legacyTypes = legacyTypeRepository.findAllByProjectIdOrderByCode(projectId);
        var scenarioExecutionTypesReadyForMigration = legacyTypes.stream()
                .filter(type -> type.getSource() != null)
                .map(type -> getMigrationScenarioExecutionTypeFromLegacyType(type, migrationProject, scenarioTypesReadyForMigration))
                .collect(Collectors.toList());
        migrationScenarioExecutionTypeRepository.saveAll(scenarioExecutionTypesReadyForMigration);
    }

    /**
     * Get migration scenario execution type from legacy type
     * @param legacyType the legacy type
     * @param migrationProject the migration project
     * @param scenarioTypes the migration scenario types
     * @return the converted scenario execution type
     */
    public static ScenarioExecutionType getMigrationScenarioExecutionTypeFromLegacyType(
            Type legacyType,
            Project migrationProject,
            List<ScenarioType> scenarioTypes
    ) {
        var migrationScenarioTypes = CollectionUtils.isEmpty(scenarioTypes) ? new ArrayList<ScenarioType>() : scenarioTypes;
        return new ScenarioExecutionType()
                .withId(new CodeWithProjectId().withProject(migrationProject).withCode(legacyType.getCode()))
                .withName(legacyType.getName())
                .withDescription(NEW_FIELD_GENERATION)
                .withScenarioType(
                        migrationScenarioTypes.stream()
                                .filter(scenarioType -> scenarioType.getId().getCode().equals(legacyType.getSource().getCode()))
                                .findFirst()
                                .orElse(null)
                );
    }

    /**
     * Migrate problems
     * @param legacyProject the legacy project
     * @param allMigratedTeams all the migrated teams
     * @param allMigratedRootCauses all the migrated problem root causes
     * @return the migrated problems
     */
    private List<Problem> migrateProblems(
            com.decathlon.ara.domain.Project legacyProject,
            List<Team> allMigratedTeams,
            List<ProblemRootCause> allMigratedRootCauses
    ) {
        var legacyProblems = legacyProblemRepository.findByProjectId(legacyProject.getId());
        var problemsReadyForMigration = legacyProblems.stream()
                .map(legacyProblem -> getMigrationProblemFromLegacyProblem(legacyProblem, allMigratedTeams, allMigratedRootCauses))
                .collect(Collectors.toList());
        return migrationProblemRepository.saveAll(problemsReadyForMigration);
    }

    /**
     * Migrate patterns
     * @param legacyProject the legacy project
     * @param allMigratedProblems all the migrated problems
     */
    private void migratePatterns(
            com.decathlon.ara.domain.Project legacyProject,
            List<Problem> allMigratedProblems
    ) {
        var legacyPatterns = legacyProblemPatternRepository.findAllByProjectId(legacyProject.getId());
        var patternsReadyForMigration = legacyPatterns.stream()
                .map(legacyPattern -> getMigrationPatternFromLegacyPattern(legacyPattern, allMigratedProblems))
                .collect(Collectors.toList());
        migrationScenarioErrorTracePatternRepository.saveAll(patternsReadyForMigration);
    }

    /**
     * Get migration pattern from legacy pattern
     * @param legacyPattern the legacy pattern
     * @param allMigratedProblems all the migrated problems
     * @return the migration pattern
     */
    private ScenarioErrorTracePattern getMigrationPatternFromLegacyPattern(
            ProblemPattern legacyPattern,
            List<Problem> allMigratedProblems
    ) {
        Optional<Problem> migratedProblem = Optional.empty();
        var legacyProblem = legacyPattern.getProblem();
        if (legacyProblem != null) {
            migratedProblem = allMigratedProblems.stream()
                    .filter(problem -> problem.getName().equals(legacyProblem.getName()))
                    .findFirst();
        }
        String migrationTag = null;
        var legacyCountry = legacyPattern.getCountry();
        if (legacyCountry != null) {
            migrationTag = legacyCountry.getCode();
        }
        String migrationTechnology = null;
        var legacyType = legacyPattern.getType();
        if (legacyType != null) {
            migrationTechnology = legacyType.getCode();
        }
        return new ScenarioErrorTracePattern()
                .withPattern(legacyPattern.getException())
                .withProblem(migratedProblem.orElse(null))
                .withSnapshotFilterValue(
                        new ScenarioErrorTracePattern.SnapshotFilterValue()
                                .withRelease(legacyPattern.getRelease())
                                .withEnvironment(legacyPattern.getPlatform())
                                .withScenario(legacyPattern.getScenarioName())
                                .withStep(legacyPattern.getStep())
                                .withTag(migrationTag)
                                .withTechnology(migrationTechnology)
                );
    }

    /**
     * Get migration problem from legacy problem
     * @param legacyProblem the legacy problem
     * @param allMigratedTeams all the migrated teams
     * @param allMigratedRootCause all the migrated problem root causes
     * @return the migration problem
     */
    private Problem getMigrationProblemFromLegacyProblem(
            com.decathlon.ara.domain.Problem legacyProblem,
            List<Team> allMigratedTeams,
            List<ProblemRootCause> allMigratedRootCause
    ) {
        var migrationProblemStatus = com.decathlon.ara.domain.enumeration.ProblemStatus.OPEN.equals(legacyProblem.getStatus()) ?
                ProblemStatus.OPEN :
                ProblemStatus.CLOSED;
        Optional<ProblemRootCause> selectedProblemRootCause = Optional.empty();
        var legacyProblemRootCause = legacyProblem.getRootCause();
        if (legacyProblemRootCause != null) {
            selectedProblemRootCause = allMigratedRootCause.stream()
                    .filter(migratedRootCause -> migratedRootCause.getName().equals(legacyProblemRootCause.getName()))
                    .findFirst();
        }

        Optional<Team> selectedMigratedTeam = Optional.empty();
        var legacyProblemTeam = legacyProblem.getBlamedTeam();
        if (legacyProblemTeam != null) {
            selectedMigratedTeam = allMigratedTeams.stream()
                    .filter(migratedTeam -> migratedTeam.getName().equals(legacyProblemTeam.getName()))
                    .findFirst();
        }
        return new Problem()
                .withName(legacyProblem.getName())
                .withDescription(NEW_FIELD_GENERATION)
                .withComment(legacyProblem.getComment())
                .withStatus(migrationProblemStatus)
                .withCreationDateTime(legacyProblem.getCreationDateTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime())
                .withDefectClosingDateTime(legacyProblem.getClosingDateTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime())
                .withFirstOccurrenceDateTime(legacyProblem.getFirstSeenDateTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime())
                .withLastOccurrenceDateTime(legacyProblem.getLastSeenDateTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime())
                .withDefectCode(legacyProblem.getDefectId())
                .withTeam(selectedMigratedTeam.orElse(null))
                .withRootCause(selectedProblemRootCause.orElse(null));
    }

    /**
     * Migrate teams
     * @param legacyProject the legacy project
     * @param migrationProject the migration project
     * @return the migrated teams
     */
    private List<Team> migrateTeams(com.decathlon.ara.domain.Project legacyProject, Project migrationProject) {
        var legacyTeams = legacyTeamRepository.findAllByProjectIdOrderByName(legacyProject.getId());
        var teamsReadyForMigration = legacyTeams.stream()
                .map(legacyTeam -> new Team()
                        .withId(
                                new CodeWithProjectId()
                                        .withProject(migrationProject)
                                        .withCode(getCodeFromName(legacyTeam.getName()))
                        )
                        .withName(legacyTeam.getName())
                        .withDescription(NEW_FIELD_GENERATION)
                        .withAssignableToFeatures(legacyTeam.isAssignableToFunctionalities())
                        .withAssignableToProblems(legacyTeam.isAssignableToProblems())
                )
                .collect(Collectors.toList());
        return migrationTeamRepository.saveAll(teamsReadyForMigration);
    }

    /**
     * Migrate problem root causes
     * @param legacyProject the legacy project
     * @param migrationProject the migration project
     * @return the migrated problem root causes
     */
    private List<ProblemRootCause> migrateRootCauses(com.decathlon.ara.domain.Project legacyProject, Project migrationProject) {
        var legacyRootCauses = legacyRootCauseRepository.findAllByProjectIdOrderByName(legacyProject.getId());
        var rootCausesReadyForMigration = legacyRootCauses.stream()
                .map(legacyRootCause -> new ProblemRootCause()
                        .withId(
                                new CodeWithProjectId()
                                        .withProject(migrationProject)
                                        .withCode(getCodeFromName(legacyRootCause.getName()))
                        )
                        .withName(legacyRootCause.getName())
                        .withDescription(NEW_FIELD_GENERATION)
                )
                .collect(Collectors.toList());
        return migrationRootCauseRepository.saveAll(rootCausesReadyForMigration);
    }

    /**
     * Transform a name into a code, i.e. delete all special char and replace them with '_'
     * @param name the name to transform
     * @return the code
     */
    private String getCodeFromName(String name) {
        if (StringUtils.isBlank(name)) {
            return "";
        }
        return Arrays
                .stream(name.split("\\W+"))
                .map(String::toLowerCase)
                .collect(Collectors.joining("_"));
    }

    /**
     * Convert a date into a local date time
     * @param date the date to convert
     * @return the converted local date time
     */
    public static LocalDateTime getDateFromLocalDateTime(Date date) {
        if (date == null) {
            return null;
        }
        return date
                .toInstant()
                .atZone(ZoneId.systemDefault())
                .toLocalDateTime();
    }
}
